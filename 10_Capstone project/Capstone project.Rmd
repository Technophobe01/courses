---
title: "Data Science Capstone - Yelp Dataset Analysis"
author: "Technophobe1"
date: "November 2, 2015"
output: 
  html_document: 
    highlight: tango
    number_sections: yes
    theme: cerulean
    toc: no
---

```{r setOptions, echo = FALSE, message = FALSE, error = FALSE, warning = FALSE, results = 'hide'}
# Here we set the default knitr options and then override as the point of use...
require(knitr)
opts_chunk$set(echo = FALSE, message = FALSE, error = FALSE, warning = FALSE, results = 'hide', fig.width = 16, fig.height = 8)
require(knitcitations)
cleanbib()
```

```{r Setup, echo=FALSE, message=FALSE, results='hide'}
setwd("~/Documents/Dropbox/dev/cousera/courses/10_Capstone project")

requiredPackages <- c("devtools","dplyr","tidyr","data.table","ggplot2","ggvis",
                      "RMySQL", "jsonlite", "psych", "plyr", "knitr", "pander",
                      "maps", "mapproj", "maptools", "ggmap")

ipak <- function(pkg)
{
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg))
    install.packages(new.pkg, dependencies = TRUE)
  sapply(pkg, require, character.only = TRUE)
}

ipak(requiredPackages)
```

# Predictive Review by Location and Business Type

The problem and question I wish to ask and answer is 

- "In what region of the Yelp Dataset Challenge dataset does the highest density of a particular form of restaurant occur and which region gives the best review to a particular form of restaurant in the context of a particular event such as Mothers Day, or Fathers Day"_. Secondly, _**"Can we predict that restuarants of type X in region Y have a higher probability of a good review?"**_"

The intent is to combine both location, and temporal data and natural language processing to determine if a correlation exists between location, type of restaurant and event. For example can we determine if the hypothesis _**"People in region X, have the highest density of Chinese restuarants, yet give the best reviews to Italian restaurants on Father's Day"**_ is true, false or non-answerable based on the data-set we are using?

## Data Import

```{r Data_Download }

dataDir         <- "./data"
fileUrl         <- "https://d396qusza40orc.cloudfront.net/dsscapstone/dataset/yelp_dataset_challenge_academic_dataset.zip"
filePath        <- file.path(dataDir)

# Does the directory Exist? If it does'nt create it
if (!file.exists(dataDir)) {
  dir.create(dataDir)
}

# Now we check if we have downloaded the data already into 
# "./data/yelp_dataset_challenge_academic_dataset". If not, then we download the
# zip file... and extract it under the data directory as 
# './data/yelp_dataset_challenge_academic_dataset'...

if (!file.exists( file.path(dataDir,"yelp_dataset_challenge_academic_dataset"))) {
  temp <- tempfile()
  download.file(fileUrl, temp, mode = "wb", method = "curl")
  unzip(temp, exdir = dataDir)
  unlink(temp)
}
```


```{r Data_Import, cache=TRUE }

# OK, now we have downloaded the data, we now need to import it into R and clean
# it... We have five datasets:
#  
#   1) Business, 2) Checkin, 3) Review, 4) tip, 5) User
# 

# Load the dataset in preperation for manipulation... note that we first check
# to see if the datframe exists as we do not want to reload the data every time
# we compile the markdown file :-)

dataDir <- "./data/yelp_dataset_challenge_academic_dataset"

if ( !exists("yelpBusinessData") )
{
  if (file.exists( file.path(dataDir,"yelpBusinessData.rds"))) {
    yelpBusinessData <- readRDS(file.path(dataDir,"yelpBusinessData.rds"))
  } else {
    yelpBusinessDataFilePath <- file.path(dataDir, 
                                          "yelp_academic_dataset_business.json")
    yelpBusinessData <- fromJSON(sprintf("[%s]",
                                         paste(readLines(yelpBusinessDataFilePath),
                                               collapse = ",")),
                                 flatten = FALSE)
    str(yelpBusinessData, max_level = 1)
    # Fix the column name duplication issue
    # If and when you flatten the data the you create two columns wiht the same column id
    # 
    # i.e. yelpBusinessData$attributes.Good.for.kids
    # 
    # This fixes the issue by renaming the first column...
    colnames(yelpBusinessData$attributes)[7] <- "Good_For_Kids"
    colnames(yelpBusinessData$attributes)[6] <- "Price_Range"
    saveRDS( yelpBusinessData, file.path(dataDir, "yelpBusinessData.rds"))
  }
}

if ( !exists("yelpCheckInData") ) {
  if (file.exists( file.path(dataDir,"yelpCheckInData.rds"))) {
    yelpCheckInData <- readRDS( file.path(dataDir, "yelpCheckInData.rds"))
  } else {
    yelpCheckInDataFilePath <- file.path(dataDir, "yelp_academic_dataset_checkin.json")
    yelpCheckInData <- fromJSON(sprintf("[%s]", paste(readLines(yelpCheckInDataFilePath), collapse = ",")), flatten = FALSE)
    str(yelpCheckInData)
    saveRDS( yelpCheckInData, file.path(dataDir, "yelpCheckInData.rds"))
  }
}

if ( !exists("yelpReviewData") ) {
  if (file.exists( file.path(dataDir,"yelpCheckInData.rds"))) {
    yelpReviewData <- readRDS(file.path(dataDir, "yelpReviewData.rds"))
  } else {
    yelpReviewDataFilePath <- file.path(dataDir, "yelp_academic_dataset_review.json")
    yelpReviewData <- fromJSON(sprintf("[%s]", paste(readLines(yelpReviewDataFilePath), collapse = ",")), flatten = FALSE)
    str(yelpReviewData)
    saveRDS( yelpReviewData, file.path(dataDir, "yelpReviewData.rds"))
  }
}

if ( !exists("yelpTipData") ) {
  if (file.exists( file.path(dataDir,"yelpTipData.rds"))) {
    yelpTipData <- readRDS(file.path(dataDir, "yelpTipData.rds"))
  } else {
    yelpTipDataFilePath <- file.path(dataDir, "yelp_academic_dataset_tip.json")
    yelpTipData <- fromJSON(sprintf("[%s]", paste(readLines(yelpTipDataFilePath), collapse = ",")), flatten = FALSE)
    str(yelpTipData)
    saveRDS( yelpTipData, file.path(dataDir, "yelpTipData.rds"))
  }
}

if ( !exists("yelpUserData") ) {
  if (file.exists( file.path(dataDir,"yelpUserData.rds"))) {
     yelpUserData <- readRDS(file.path(dataDir, "yelpUserData.rds"))
  } else {
    yelpUserDataFilePath <- file.path(dataDir, "yelp_academic_dataset_user.json")
    yelpUserData <- fromJSON(sprintf("[%s]", paste(readLines(yelpUserDataFilePath), collapse = ",")), flatten = FALSE)
    str(yelpUserData)
    saveRDS( yelpUserData, file.path(dataDir, "yelpUserData.rds"))
  }
}
```

```{r create_database, cache=TRUE}
# We now have the data loaded... Next step is to move the data into a MySql 
# database. This is good practice as we can then use dplyr to access and
# manipulate the data without having to keep all the tables in memory...

# The dbConnect command below connects the database, rather than putting the
# password and data in the file, like so:
# 
# conDB <- dbConnect(RMySQL::MySQL(),
#                 user = 'root',
#                 password = 'SecurityRisk!!!!',
#                 host = '127.0.0.1',
#                 port = 3306,
#                 dbname = 'Capstone')
#
# we create a seperate '~/.my.cnf' file, which we place in the users top level
# directory, we then access the data via the database name...
# 
# Example '~/.my.cnf' file...
# 
# [client]
# user = root
# host = localhost
# password = NotTelling!!!!!
# [theDatabase]
# database = Capstone
#
# Now we just access the database by name and no password is exposed in the
# source code...
# 
conDB <- dbConnect(RMySQL::MySQL(), group = 'CapstoneDB')

# The Next step is to flatten each file and then write it to the MySQL database 
# 'Capstone' we created earlier. Note that we use Mamp Pro standard settings. i.e. 
# Launch MAMP Pro, launch RSTUDIO...
# 
# OK, now write the tables out to the database 'Capstone'
# 
# We check to see if the tables exist in Capstone as we do not want to re-create
# if they already exists...
# 
if (!dbExistsTable(conDB, "yelpBusinessData") ) {
  yelpBusinessDataFlat <- flatten(yelpBusinessData, recursive = TRUE)
  yelpBusinessDataFlat$categories <- sapply(yelpBusinessDataFlat$categories, toString)
  yelpBusinessDataFlat$neighborhoods <- sapply(yelpBusinessDataFlat$neighborhoods, toString)
  yelpBusinessDataFlat$`attributes.Accepts Credit Cards` <- sapply(yelpBusinessDataFlat$`attributes.Accepts Credit Cards`, toString)
  dbWriteTable(conn = conDB, name = 'yelpBusinessData', value = as.data.frame(yelpBusinessDataFlat), overwrite = TRUE)
  rm(yelpBusinessDataFlat) # Save Space
}


if (!dbExistsTable(conDB, "yelpCheckInData") ) {
  yelpCheckInDataFlat <- flatten(yelpCheckInData, recursive = TRUE)
  dbWriteTable(conn = conDB, name = 'yelpCheckInData', value = as.data.frame(yelpCheckInDataFlat), overwrite = TRUE)
  rm(yelpCheckInDataFlat) # Save Space
}

if (!dbExistsTable(conDB, "yelpReviewData") ) {
  yelpReviewDataFlat <- flatten(yelpReviewData, recursive = TRUE)
  dbWriteTable(conn = conDB, name = 'yelpReviewData', value = as.data.frame(yelpReviewDataFlat), overwrite = TRUE)
  rm(yelpReviewDataFlat) # Save Space
}

if (!dbExistsTable(conDB, "yelpTipData") ) {
  yelpTipDataFlat <- flatten(yelpTipData, recursive = TRUE)
  dbWriteTable(conn = conDB, name = 'yelpTipData', value = as.data.frame(yelpTipDataFlat), overwrite = TRUE)
  rm(yelpTipDataFlat) # Save Space
}

if (!dbExistsTable(conDB, "yelpUserData") ) {
  yelpUserDataFlat <- flatten(yelpUserData, recursive = TRUE)
  yelpUserDataFlat$friends <- sapply(yelpUserData$friends, toString)
  yelpUserDataFlat$elite <- sapply(yelpUserData$elite, toString)
  rm(yelpTipDataFlat) # Save Space
  
  dbWriteTable(conn = conDB, name = 'yelpUserData', value = as.data.frame(yelpUserDataFlat), overwrite = TRUE)
}

dbListTables(conDB)
dbDisconnect(conDB)

```
## Exploratory Analysis


The yelp dataset includes:

- 1.6M reviews and 500K tips by 366K users for 61K businesses
- 481K business attributes, e.g., hours, parking availability, ambience.
- Social network of 366K users for a total of 2.9M social edges.
- Aggregated check-ins over time for each of the 61K businesses

The datset covers 10 cities...
 
- U.K.: Edinburgh
- Germany: Karlsruhe
- Canada: Montreal and Waterloo
- U.S.: Pittsburgh, Charlotte, Urbana-Champaign, Phoenix, Las Vegas, Madison

Our goal here is to do an initial mapping of the geo data, nothing to complex our goals are to explore the data. We start with a macro view, what cities do we have in the data set? From that we can then start to look at the geographic data...
 
```{r InitialAnalysis, cache = TRUE}

# Flatten Data
yelpBusinessData <- flatten(yelpBusinessData, recursive = TRUE)

# The Yelp Dataset describes 10 Cities, is that true?
# Lets partition the yelp data set into 10 clusters and then map those cluster to location

geo.cluster <- kmeans(yelpBusinessData[,c('longitude','latitude')], 10)
geo.cluster$centers

# We can see that the goe.clusters result skews to the US data due to relative size of cluster...
```

```{r Mapping, cache = TRUE}

cities <- c('Edinburgh, UK', 
          'Karlsruhe, Germany', 
          'Montreal, Canada', 'Waterloo, Canada', 
          'Pittsburgh, PA', 'Charlotte, NC', 'Urbana-Champaign, IL', 'Phoenix, AZ', 'Las Vegas, NV', 'Madison, WI')

city.centres <- geocode(cities, source = "google")
geo.cluster <- kmeans(yelpBusinessData[,c('longitude','latitude')],city.centres)
# summary(geo.cluster)

# Now we can map these clusters to a map of the world to get a sense of the 
# data... Here what we do os map the cluster centers to the map and scale the 
# point size to the cluster size of the kmeans clusters...
# 
# Note the relative size of the clusters - Phoenix data set is considerably
# larger than the UK and German data sets...
# 
# 
gp <- ggplot(data.frame(geo.cluster$centers), 
             aes(longitude, latitude, color = cities))
gp <- gp + borders("world", background = "lightblue", fill = "white", col = "cornflowerblue") 
gp <- gp + geom_point(aes(size = geo.cluster$size))
gp <- gp + geom_text(aes(city.centres$lon, city.centres$lat, label = cities), 
                     size = 3, hjust = -0.2, vjust = .3, color = "black", name = "Cities \n")
gp <- gp + scale_size_area(name = "Cluster Size \n")
gp
rm(gp)

require(dplyr)
# convert to numeric
clusterAnalysis <- data.frame(cbind(City = cities, Cluster = geo.cluster$size))
clusterAnalysis$Cluster <- as.numeric(as.character(clusterAnalysis$Cluster))

```

What we find is that the size of the relative geospatial datasets sku's the initial result. There is not an even distribution of data by location. The map displayed in the figure above depicts and addresses this problem, the table below shows the cluster sizes. We obtain the data by pulling the geocodes for the cities referenced and use these codes to create the cluster buckets. Note that if we sum the buckets we get: `r format(sum(clusterAnalysis$Cluster), scientific=FALSE)` , which aligns with the sampe row size of `yelpBusinessData`

```{r, results='asis'}

kable(arrange(clusterAnalysis,Cluster))

```

Now we have a sense of the data clusters and their sizes, lets take a look at the next component of the proposed analysis.

- In what region of the Yelp Challenge dataset do the highest priced restuarants occcur?
- In what region of the Yelp Challenge dataset does the highest density of a particular form of restaurant occur?
- Which region gives the best review to a particular form of restaurant?

for the first question the intent is to investigate the types of restuarant by cluster, and then prioratise them by cluster. We can then look at the type of restuarant as a % of restuarants by cluster to determine popularity aginst rating.

For example, we can create a subset for Phoenix and create a cluster map that examines the price denisity of restuarants. Lookign at the data we see that there is a cluster of expensive restaurants downtown. Looking at the data we see:

```{r mapSetup}
map <- get_map(location = 'Las Vegas, NV', zoom = 10, maptype = "roadmap")
yelpBusinessData$city <- as.factor(yelpBusinessData$city)
yelpBusinessData.NV <- yelpBusinessData[which(yelpBusinessData$city == "Las Vegas"),]
# Only restaurants (as in category)
yelpBusinessData.NV.rest <- yelpBusinessData.NV[which(grepl("Restaurants", yelpBusinessData.NV$categories)),]
```

```{r describeData, results='asis'}
kable(describe( yelpBusinessData.NV.rest$attributes.Price_Range))
pander(count( yelpBusinessData.NV.rest$attributes.Price_Range ))

```
Firstly, lets just look at all the Las Vegas restaurants that are open and map out their price range...

```{r lasVegasPriceDensity}
lasVegasPrice <- yelpBusinessData %>% 
  filter(city == "Las Vegas") %>%
  filter(grepl("Restaurants", categories)) %>%
  filter(open == TRUE)

mP <- ggmap(map, extent = "device", legend = "topright")
mP <- mP + geom_point( data = lasVegasPrice,
                      aes( x = lasVegasPrice$longitude,
                           y = lasVegasPrice$latitude,
                           color = lasVegasPrice$attributes.Price_Range,
                           size =  lasVegasPrice$attributes.Price_Range),
                      alpha = 0.5 )

# Set the Legend to be a continous colour bar... 
mP <- mP + scale_colour_continuous(low = "blue", 
                                   high = "red", 
                                   space = "Lab", 
                                   guide = "colorbar", 
                                   name = "Price Range \n")
mP <- mP + scale_size_area(name = "Price Range \n")
mP

rm(mP)

```

OK, where are the expensive restaurants?... Lets look at the restaurants with a price range of between 3 and 4...

```{r lasVegasExpDensity }

lasVegasExpDensity <- yelpBusinessData %>% 
  filter(city == "Las Vegas") %>%
  filter(grepl("Restaurants", categories)) %>%
  filter(open == TRUE) %>%
  filter( (attributes.Price_Range == 3 | attributes.Price_Range == 4) )

# lasVegasExpDensity <- lasVegasExpDensity[which(lasVegasExpDensity$attributes$Price_Range == 3 |
#     lasVegasExpDensity$attributes$Price_Range == 4),]

mP <- ggmap(map, extent = "device", legend = "topright")
mP <- mP + geom_point( data = lasVegasExpDensity,
                      aes( x = lasVegasExpDensity$longitude,
                           y = lasVegasExpDensity$latitude,
                           color = lasVegasExpDensity$attributes.Price_Range,
                           size =  lasVegasExpDensity$attributes.Price_Range),
                      alpha = 0.5 )

# Set the Legend to be a continous colour bar... 
mP <- mP + scale_colour_continuous(low = "blue", 
                                   high = "red", 
                                   space = "Lab", 
                                   guide = "colorbar", 
                                   name = "Price Range\n")

mP <- mP + scale_size_area(name = "Price Range \n")
mP
```

Hmmm, now lets look at restaurants with good star ratings [3 through 4] and a price range of 3 through 4... 

```{r lasVegasDensityStarByPrice }
Exp <- yelpBusinessData %>% 
  filter(city == "Las Vegas") %>%
  filter(grepl("Restaurants", categories)) %>%
  filter(open == TRUE) %>% 
  filter( stars > 3 ) %>%
  filter( (attributes.Price_Range == 3 | attributes.Price_Range == 4) )

#  filter( (attributes[[6]][] == 3 | attributes[[6]][] == 4) )
# 
# Exp <- yelpBusinessData.PA.rest[which(yelpBusinessData.PA.rest$attributes$Price_Range == 3 |
#     yelpBusinessData.PA.rest$attributes$Price_Range == 4),]

mP <- ggmap(map, extent = "device", legend = "topright")
mP <- mP + geom_point( data = Exp,
                      aes( x = Exp$longitude,
                           y = Exp$latitude,
                           color = Exp$attributes.Price_Range,
                           size =  Exp$stars),
                      alpha = 0.5 )

# Set the Legend to be a continous colour bar... 
mP <- mP + scale_colour_continuous(low = "blue", 
                                   high = "red", 
                                   space = "Lab", 
                                   guide = "colorbar", 
                                   name = "Price Range\n")

mP <- mP + scale_size_area(name = "Star Range \n")
mP
```

Note that in Las Vegas the median star rating is: **`r median(lasVegasPrice$stars, na.rm = TRUE)`** and the median Price range is **`r median(lasVegasPrice$attributes.Price_Range, na.rm = TRUE)`**. Hence, we see that when we focus interest on higher priced restaurant we see a slight sku to the the center of town. 

### Restaurant Density by Type?

Ok, so we have observed the star ratings and price range interaction. What of restaurant reviews? What types of restuarant exist, and which restuarants get the best reviews?




## Methods and Data
- Describe how you used the data and the type of analytic methods that you used; it's okay to be a bit technical here but clarity is important

## Results 
- Describe what you found through your analysis of the data.

## Discussion
- Explain how you interpret the results of your analysis and what the implications are for your question/problem.

